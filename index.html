<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BMP (24-bit) → bmp.h (12bpp, PCF8833)</title>
  <style>
    :root{
      --bg:#0b0e14; --panel:#111827; --panel2:#0f172a; --text:#e5e7eb; --muted:#9ca3af;
      --accent:#60a5fa; --accent2:#22c55e; --danger:#fb7185; --border:rgba(255,255,255,.10);
    }
    *{box-sizing:border-box}
    html, body{height:100%}
    html{
      background:radial-gradient(1200px 600px at 10% 0%, rgba(96,165,250,.18), transparent 60%),
      radial-gradient(900px 600px at 90% 10%, rgba(34,197,94,.12), transparent 60%),
      var(--bg);
      background-repeat:no-repeat;
      background-attachment:fixed;
    }
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      min-height:100%;
      background:transparent;
      color:var(--text);
    }
    .wrap{max-width:1100px;margin:0 auto;padding:28px 18px 64px}
    .pageHeader{display:flex;gap:14px;align-items:flex-start;justify-content:space-between;flex-wrap:wrap}
    h1{margin:0;font-size:22px;letter-spacing:.2px}
    .sub{margin:6px 0 0;color:var(--muted);font-size:13px;line-height:1.45}
    .grid{display:grid;grid-template-columns:minmax(0,1.1fr) minmax(0,.9fr);gap:16px;margin-top:18px}
    @media (max-width: 920px){.grid{grid-template-columns:1fr;}}

    .card{background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.03));
      border:1px solid var(--border); border-radius:18px; padding:16px; box-shadow:0 12px 30px rgba(0,0,0,.35)}
    .card h2{margin:0 0 10px;font-size:14px;color:#dbeafe;font-weight:650;letter-spacing:.2px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    label{font-size:12px;color:var(--muted)}
    input[type="file"], select, input[type="number"], input[type="text"]{
      background:rgba(15,23,42,.9); border:1px solid var(--border); color:var(--text);
      padding:10px 12px; border-radius:12px; outline:none; min-height:40px;
    }
    input[type="number"]{width:110px}
    select{min-width:180px}
    .btn{
      appearance:none; border:1px solid var(--border);
      background:rgba(96,165,250,.12);
      color:var(--text);
      padding:10px 12px; border-radius:12px; cursor:pointer; min-height:40px;
      transition:transform .04s ease, background .15s ease, border-color .15s ease;
      font-weight:650; letter-spacing:.2px;
    }
    .btn:hover{background:rgba(96,165,250,.18); border-color:rgba(96,165,250,.35)}
    .btn:active{transform:translateY(1px)}
    .btn.secondary{background:rgba(255,255,255,.06)}
    .btn.secondary:hover{background:rgba(255,255,255,.10)}
    .btn.good{background:rgba(34,197,94,.14)}
    .btn.good:hover{background:rgba(34,197,94,.20); border-color:rgba(34,197,94,.35)}
    .btn:disabled{opacity:.55; cursor:not-allowed}

    .pill{display:inline-flex;align-items:center;gap:8px;border:1px solid var(--border);
      padding:8px 10px;border-radius:999px;background:rgba(255,255,255,.04);font-size:12px;color:var(--muted)}
    .pill b{color:var(--text)}

    details{margin-top:10px}
    details summary{cursor:pointer; color:#c7d2fe; font-size:12px; user-select:none}
    .adv{margin-top:10px; display:grid; grid-template-columns:repeat(3, minmax(0,1fr)); gap:10px}
    @media (max-width: 920px){.adv{grid-template-columns:1fr;}}

    .preview{display:grid; grid-template-columns:1fr 1fr; gap:12px}
    @media (max-width: 600px){.preview{grid-template-columns:1fr;}}
    .canvasWrap{background:rgba(15,23,42,.65); border:1px dashed rgba(255,255,255,.18);
      border-radius:16px; padding:10px}
    .canvasWrap header{display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:nowrap;margin-bottom:8px}
    .canvasWrap header .t{font-size:12px;color:var(--muted)}
    canvas{width:100%; height:auto; image-rendering:pixelated; border-radius:12px; background:#0b1220}

    textarea{width:100%; min-height:190px; resize:vertical;
      background:rgba(15,23,42,.9); border:1px solid var(--border);
      color:var(--text); padding:12px; border-radius:14px; outline:none;
      font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;
      font-size:12px; line-height:1.35;
    }

    .msg{margin-top:10px; padding:10px 12px; border-radius:14px; border:1px solid var(--border);
      background:rgba(255,255,255,.05); color:var(--muted); font-size:12px; line-height:1.45}
    .msg.err{border-color:rgba(251,113,133,.35); background:rgba(251,113,133,.10); color:#fecdd3}
    .msg.ok{border-color:rgba(34,197,94,.35); background:rgba(34,197,94,.10); color:#bbf7d0}

    .footerNote{margin-top:12px;color:var(--muted);font-size:12px;line-height:1.45}
    a{color:#93c5fd}
  </style>
</head>
<body>
<div class="wrap">
  <header class="pageHeader">
    <div>
      <h1>BMP (24-bit) → <code>bmp.h</code> (12bpp, 2 pix = 3 bajty)</h1>
      <p class="sub">
        Stronka umożliwia zamiane pliku .bmp na C array w bmp.h .
      </p>
    </div>
    <div class="row">
      <span class="pill"><b>Format wyjścia:</b> 12bpp RGB444, pakowanie 2px→3B</span>
    </div>
  </header>

  <div class="grid">
    <section class="card">
      <h2>1) Wejście</h2>
      <div class="row" style="margin-bottom:10px">
        <div style="flex:1;min-width:240px">
          <label>Plik BMP (24-bit, BI_RGB)</label><br/>
          <input id="file" type="file" accept=".bmp,image/bmp" />
        </div>
        <div style="min-width:220px;flex:0">
          <label>Nazwa tablicy (opcjonalnie)</label><br/>
          <input id="arrName" type="text" value="bmp" spellcheck="false" />
        </div>
      </div>

      <div class="row" style="margin-bottom:10px">
        <div>
          <label>Preset rozmiaru</label><br/>
          <select id="preset">
            <option value="130x130">130 × 130</option>
            <option value="132x132" selected>132 × 132</option>
            <option value="128x128">128 × 128</option>
            <option value="96x96">96 × 96</option>
            <option value="custom">Własny…</option>
          </select>
        </div>
        <div>
          <label>Szerokość (W)</label><br/>
          <input id="w" type="number" min="1" max="2048" value="132" />
        </div>
        <div>
          <label>Wysokość (H)</label><br/>
          <input id="h" type="number" min="1" max="2048" value="132" />
        </div>
        <div>
          <label>&nbsp;</label><br/>
          <button id="convert" class="btn good" disabled>Konwertuj</button>
        </div>
      </div>

      <details>
        <summary>Opcje zaawansowane (obrót / odbicie / dopasowanie)</summary>
        <div class="adv">
          <div>
            <label>Dopasowanie do rozmiaru</label><br/>
            <select id="fit">
              <option value="cover" selected>Cover (wypełnij, przytnij)</option>
              <option value="contain">Contain (zmieść, dodaj marginesy)</option>
              <option value="stretch">Stretch (rozciągnij)</option>
            </select>
          </div>
          <div>
            <label>Obrót</label><br/>
            <select id="rot">
              <option value="0" selected>0°</option>
              <option value="90">90°</option>
              <option value="180">180°</option>
              <option value="270">270°</option>
            </select>
          </div>
          <div class="row" style="align-items:flex-end">
            <div style="flex:1">
              <label>Odbicie</label><br/>
              <div class="row" style="gap:8px">
                <label class="pill" style="cursor:pointer"><input id="flipH" type="checkbox" style="margin:0" />&nbsp;Poziomo</label>
                <label class="pill" style="cursor:pointer"><input id="flipV" type="checkbox" style="margin:0" />&nbsp;Pionowo</label>
              </div>
            </div>
          </div>
        </div>
      </details>

      <div id="status" class="msg" style="margin-top:12px">Wybierz plik BMP, a potem kliknij „Konwertuj”.</div>

      <div class="footerNote">
        Tip: jeśli kolory wyjdą „zamienione” (R↔B), użyj opcji <b>Odbicie</b> nie pomoże — wtedy trzeba zmienić mapowanie kanałów w JS.
        W tym narzędziu generujemy standardowe RGB444 (0xRGB).
      </div>
    </section>

    <section class="card">
      <h2>2) Podgląd i eksport</h2>
      <div class="preview" style="margin-bottom:12px">
        <div class="canvasWrap">
          <header>
            <div class="t">Wejściowy BMP</div>
            <div class="pill" id="srcMeta">—</div>
          </header>
          <canvas id="srcCanvas" width="10" height="10"></canvas>
        </div>
        <div class="canvasWrap">
          <header>
            <div class="t">Po dopasowaniu do (W×H)</div>
            <div class="pill" id="dstMeta">—</div>
          </header>
          <canvas id="dstCanvas" width="10" height="10"></canvas>
        </div>
      </div>

      <div class="row" style="margin-bottom:10px">
        <button id="download" class="btn" disabled>Pobierz <code>bmp.h</code></button>
        <button id="copy" class="btn secondary" disabled>Kopiuj do schowka</button>
        <span class="pill" id="outMeta">—</span>
      </div>

      <label>Wygenerowany plik</label>
      <textarea id="out" spellcheck="false" readonly></textarea>
    </section>
  </div>

  <div class="footerNote" style="margin-top:18px">
    SW 2025
  </div>
</div>

<script>
  (() => {
    const $ = (id) => document.getElementById(id);

    const elFile = $("file");
    const elPreset = $("preset");
    const elW = $("w");
    const elH = $("h");
    const elConvert = $("convert");
    const elDownload = $("download");
    const elCopy = $("copy");
    const elOut = $("out");
    const elStatus = $("status");
    const elArrName = $("arrName");

    const elFit = $("fit");
    const elRot = $("rot");
    const elFlipH = $("flipH");
    const elFlipV = $("flipV");

    const srcCanvas = $("srcCanvas");
    const dstCanvas = $("dstCanvas");
    const srcMeta = $("srcMeta");
    const dstMeta = $("dstMeta");
    const outMeta = $("outMeta");

    let parsed = null; // {width,height,rgba}
    let lastHeaderText = "";
    let lastBlobUrl = null;

    // ---------------- BMP parsing (24-bit, BI_RGB) ----------------
    function parseBmp24(arrayBuffer) {
      const dv = new DataView(arrayBuffer);
      if (dv.byteLength < 54) throw new Error("Plik za mały, to nie wygląda jak BMP.");

      // Signature 'BM'
      const sig0 = dv.getUint8(0), sig1 = dv.getUint8(1);
      if (sig0 !== 0x42 || sig1 !== 0x4D) throw new Error("To nie jest BMP (brak sygnatury 'BM').");

      const pixelOffset = dv.getUint32(10, true);
      const dibSize = dv.getUint32(14, true);
      if (dibSize < 40) throw new Error("Nieobsługiwany nagłówek DIB (zbyt krótki).");

      const width = dv.getInt32(18, true);
      const heightSigned = dv.getInt32(22, true);
      const planes = dv.getUint16(26, true);
      const bpp = dv.getUint16(28, true);
      const compression = dv.getUint32(30, true);

      if (planes !== 1) throw new Error("BMP: nieoczekiwana liczba planes (" + planes + ").");
      if (bpp !== 24) throw new Error("Obsługuję tylko BMP 24-bit. Ten ma: " + bpp + " bpp.");
      if (compression !== 0) throw new Error("Obsługuję tylko BMP bez kompresji (BI_RGB). Ten ma compression=" + compression + ".");
      if (width <= 0) throw new Error("BMP: szerokość niepoprawna: " + width);

      const topDown = heightSigned < 0;
      const height = Math.abs(heightSigned);

      const rowBytes = (width * 3 + 3) & ~3; // padded to 4 bytes
      const needed = pixelOffset + rowBytes * height;
      if (needed > dv.byteLength) throw new Error("BMP: dane pikseli wychodzą poza plik (uszkodzony plik?).");

      const rgba = new Uint8ClampedArray(width * height * 4);

      for (let y = 0; y < height; y++) {
        const srcY = topDown ? y : (height - 1 - y);
        const rowStart = pixelOffset + srcY * rowBytes;
        let dst = y * width * 4;
        let p = rowStart;
        for (let x = 0; x < width; x++) {
          const b = dv.getUint8(p++);
          const g = dv.getUint8(p++);
          const r = dv.getUint8(p++);
          rgba[dst++] = r;
          rgba[dst++] = g;
          rgba[dst++] = b;
          rgba[dst++] = 255;
        }
      }

      return { width, height, rgba };
    }

    // ---------------- Canvas helpers ----------------
    function drawToCanvas(canvas, img) {
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext("2d", { willReadFrequently: true });
      const id = new ImageData(img.rgba, img.width, img.height);
      ctx.putImageData(id, 0, 0);
    }

    function resizeAndTransform(srcCanvas, outW, outH, fitMode, rotDeg, flipH, flipV) {
      const out = document.createElement("canvas");
      out.width = outW;
      out.height = outH;
      const ctx = out.getContext("2d", { willReadFrequently: true });

      // Background (for contain mode borders)
      ctx.clearRect(0, 0, outW, outH);

      const sw = srcCanvas.width;
      const sh = srcCanvas.height;

      const rot = ((rotDeg % 360) + 360) % 360;
      const rot90 = (rot === 90 || rot === 270);

      let scale = 1;
      if (fitMode === "stretch") {
        // separate scales handled via drawImage directly
      } else {
        const effW = rot90 ? sh : sw;
        const effH = rot90 ? sw : sh;
        const sx = outW / effW;
        const sy = outH / effH;
        scale = (fitMode === "contain") ? Math.min(sx, sy) : Math.max(sx, sy);
      }

      ctx.save();
      ctx.imageSmoothingEnabled = true;
      ctx.translate(outW / 2, outH / 2);
      ctx.rotate(rot * Math.PI / 180);
      ctx.scale(flipH ? -1 : 1, flipV ? -1 : 1);

      if (fitMode === "stretch") {
        // Draw stretched into output rect after rotation: easiest is to draw into rect using scale factors.
        // For 90/270 the concept of "stretch" gets weird; we treat it as stretch after rotation.
        const dw = sw;
        const dh = sh;
        const sx = rot90 ? (outH / dh) : (outW / dw);
        const sy = rot90 ? (outW / dw) : (outH / dh);
        ctx.scale(sx, sy);
        ctx.drawImage(srcCanvas, -dw / 2, -dh / 2, dw, dh);
      } else {
        const dw = sw * scale;
        const dh = sh * scale;
        ctx.drawImage(srcCanvas, -dw / 2, -dh / 2, dw, dh);
      }

      ctx.restore();
      return out;
    }

    // ---------------- 24-bit RGB → 12-bit RGB444 ----------------
    function to4(v8) {
      // map 0..255 -> 0..15 with rounding
      return Math.min(15, Math.max(0, Math.floor((v8 * 15 + 127) / 255)));
    }

    function rgbaToRgb444Words(imageData) {
      const d = imageData.data;
      const n = imageData.width * imageData.height;
      const out = new Uint16Array(n);
      for (let i = 0; i < n; i++) {
        const r4 = to4(d[i * 4 + 0]);
        const g4 = to4(d[i * 4 + 1]);
        const b4 = to4(d[i * 4 + 2]);
        out[i] = (r4 << 8) | (g4 << 4) | (b4);
      }
      return out;
    }

    // 2 pixels -> 3 bytes packing (PCF8833 12bpp)
    function pack12bpp(words) {
      const pixels = words.length;
      const bytes = Math.floor((3 * pixels + 1) / 2); // ceil(12bpp)
      const out = new Uint8Array(bytes);
      let o = 0;
      for (let i = 0; i < pixels; i += 2) {
        const c0 = words[i] & 0x0FFF;
        const c1 = (i + 1 < pixels) ? (words[i + 1] & 0x0FFF) : 0x000; // padding
        out[o++] = (c0 >> 4) & 0xFF;
        out[o++] = ((c0 & 0x0F) << 4) | ((c1 >> 8) & 0x0F);
        out[o++] = c1 & 0xFF;
      }
      return out;
    }

    // ---------------- Output formatting ----------------
    function sanitizeCIdent(name) {
      name = (name || "").trim();
      if (!name) return "bmp";
      name = name.replace(/[^A-Za-z0-9_]/g, "_");
      if (!/^[A-Za-z_]/.test(name)) name = "_" + name;
      return name;
    }

    function hex2(b) {
      return "0x" + b.toString(16).padStart(2, "0");
    }

    function makeHeader(bytes, w, h, arrayName) {
      const guard = "BMP_H";
      const name = sanitizeCIdent(arrayName);

      const perLine = 24;
      let body = "";
      for (let i = 0; i < bytes.length; i++) {
        if (i % perLine === 0) body += "\n  ";
        body += hex2(bytes[i]);
        if (i !== bytes.length - 1) body += ", ";
      }

      return (
              `#ifndef ${guard}\n`+
              `#define ${guard}\n\n`+
              `// Generated by: BMP (24-bit) → bmp.h (12bpp)\n`+
              `// Format: RGB444 packed as 2 pixels = 3 bytes\n`+
              `// Size: ${w}x${h}, bytes: ${bytes.length} (ceil(3*W*H/2))\n\n`+
              `#define BMP_W ${w}\n`+
              `#define BMP_H ${h}\n\n`+
              `const unsigned char ${name}[] = {${body}\n};\n\n`+
              `#endif // ${guard}\n`
      );
    }

    // ---------------- UI wiring ----------------
    function setStatus(text, kind="") {
      elStatus.textContent = text;
      elStatus.className = "msg" + (kind ? " " + kind : "");
    }

    function refreshPresetToInputs() {
      const v = elPreset.value;
      if (v === "custom") return;
      const [pw, ph] = v.split("x").map(Number);
      elW.value = String(pw);
      elH.value = String(ph);
    }

    function refreshInputsToPreset() {
      const w = Number(elW.value), h = Number(elH.value);
      const key = `${w}x${h}`;
      const options = Array.from(elPreset.options).map(o => o.value);
      elPreset.value = options.includes(key) ? key : "custom";
    }

    elPreset.addEventListener("change", () => { refreshPresetToInputs(); });
    elW.addEventListener("input", refreshInputsToPreset);
    elH.addEventListener("input", refreshInputsToPreset);

    function revokeBlob() {
      if (lastBlobUrl) {
        URL.revokeObjectURL(lastBlobUrl);
        lastBlobUrl = null;
      }
    }

    function updateButtons() {
      const ok = !!parsed;
      elConvert.disabled = !ok;
    }

    elFile.addEventListener("change", async () => {
      revokeBlob();
      elDownload.disabled = true;
      elCopy.disabled = true;
      elOut.value = "";
      outMeta.textContent = "—";
      dstMeta.textContent = "—";

      const file = elFile.files && elFile.files[0];
      if (!file) {
        parsed = null;
        srcMeta.textContent = "—";
        setStatus("Wybierz plik BMP, a potem kliknij „Konwertuj”.");
        updateButtons();
        return;
      }

      try {
        const buf = await file.arrayBuffer();
        parsed = parseBmp24(buf);
        drawToCanvas(srcCanvas, parsed);
        srcMeta.textContent = `${parsed.width}×${parsed.height}`;
        setStatus("Plik wczytany. Ustaw rozmiar i kliknij „Konwertuj”.", "ok");
      } catch (e) {
        parsed = null;
        srcMeta.textContent = "—";
        setStatus(e?.message || String(e), "err");
        // clear canvases
        srcCanvas.width = srcCanvas.height = 10;
        dstCanvas.width = dstCanvas.height = 10;
      }

      updateButtons();
    });

    async function doConvert() {
      if (!parsed) return;

      revokeBlob();
      elDownload.disabled = true;
      elCopy.disabled = true;

      const w = Math.max(1, Math.min(2048, Number(elW.value) | 0));
      const h = Math.max(1, Math.min(2048, Number(elH.value) | 0));

      if (!Number.isFinite(w) || !Number.isFinite(h) || w <= 0 || h <= 0) {
        setStatus("Niepoprawny rozmiar W/H.", "err");
        return;
      }

      // Resize & transform
      const fitMode = elFit.value;
      const rot = Number(elRot.value) || 0;
      const flipH = !!elFlipH.checked;
      const flipV = !!elFlipV.checked;

      const outCan = resizeAndTransform(srcCanvas, w, h, fitMode, rot, flipH, flipV);

      // show preview
      dstCanvas.width = w;
      dstCanvas.height = h;
      const dstCtx = dstCanvas.getContext("2d", { willReadFrequently: true });
      dstCtx.clearRect(0, 0, w, h);
      dstCtx.drawImage(outCan, 0, 0);

      dstMeta.textContent = `${w}×${h}`;

      // Convert to bytes
      const img = dstCtx.getImageData(0, 0, w, h);
      const words = rgbaToRgb444Words(img);
      const bytes = pack12bpp(words);

      const arrayName = sanitizeCIdent(elArrName.value);
      lastHeaderText = makeHeader(bytes, w, h, arrayName);
      elOut.value = lastHeaderText;

      const expected = Math.floor((3 * (w * h) + 1) / 2);
      outMeta.textContent = `${bytes.length} B (expected ${expected} B)`;

      // enable download/copy
      const blob = new Blob([lastHeaderText], { type: "text/plain" });
      lastBlobUrl = URL.createObjectURL(blob);

      elDownload.disabled = false;
      elCopy.disabled = false;

      setStatus("Gotowe! Pobierz bmp.h albo skopiuj kod.", "ok");
    }

    elConvert.addEventListener("click", () => {
      try { doConvert(); }
      catch (e) { setStatus(e?.message || String(e), "err"); }
    });

    elDownload.addEventListener("click", () => {
      if (!lastBlobUrl || !lastHeaderText) return;
      const a = document.createElement("a");
      a.href = lastBlobUrl;
      a.download = "bmp.h";
      document.body.appendChild(a);
      a.click();
      a.remove();
    });

    elCopy.addEventListener("click", async () => {
      try {
        await navigator.clipboard.writeText(lastHeaderText || "");
        setStatus("Skopiowano do schowka ✅", "ok");
      } catch {
        setStatus("Nie udało się skopiować (przeglądarka zablokowała schowek). Skopiuj ręcznie z pola tekstowego.", "err");
      }
    });

    // initial
    refreshPresetToInputs();
    refreshInputsToPreset();
    updateButtons();
  })();
</script>
</body>
</html>
